A programmer has to be able to demonstrate that his program has the
required properties. If this comes as an afterthought, it is all but
certain that he won't be able to meet this obligation: only if he allows
this obligation to influence his design, there is hope he can meet it.
Pure a posteriori verification denies you that whole-some influence and
is therefore putting the cart before the horse, but that is exactly
what happens in the software houses where "programming" and "quality
assurance" are done by different groups. [Needless to say, those houses
deliver without warranty.]
    --Edsger Dijkstra
%
The required techniques of effective reasoning are pretty formal, but
as long as programming is done by people that don't master them, the
software crisis will remain with us and will be considered an incurable
disease. And you know what incurable diseases do: they invite the
quacks and charlatans in, who in this case take the form of Software
Engineering gurus.
    --Edsger Dijkstra
%
A number of these phenomena have been bundled under the name "Software
Engineering". As economics is known as "The Miserable Science", software
engineering should be known as "The Doomed Discipline", doomed because
it cannot even approach its goal since its goal is self-contradictory.
Software engineering, of course, presents itself as another worthy
cause, but that is eyewash: if you carefully read its literature and
analyse what its devotees actually do, you will discover that software
engineering has accepted as its charter "How to program if you cannot."
    --Edsger Dijkstra, EWD1036
%
So much for the mathematicians.
    --Edsger Dijkstra, EWD1036
%
My point today is that, if we wish to count lines of code, we should
not regard them as "lines produced" but as "lines spent": the
current conventional wisdom is so foolish as to book that count on
the wrong side of the ledger.
    --Edsger Dijkstra, EWD1036
%
In the same vein I must draw attention to the astonishing readiness
with which the suggestion has been accepted that the pains of
software production are largely due to a lack of appropriate
"programming tools". (The telling "programmer's workbench" was soon
to follow.) Again, the shallowness of the underlying analogy is
worthy of the Middle Ages. Confrontations with insipid "tools" of
the "algorithm-animation" variety has not mellowed my judgement;
on the contrary, it has confirmed my initial suspicion that we are
primarily dealing with yet another dimension of the snake oil
business.
    --Edsger Dijkstra
%
   The introduction and use of BNF (= Backus/Naur Form) to formalize
the syntax was a very courageous novelty, because many feared that it
would completely put off the computing community, but the great surprise
was that exactly the opposite happened: it was loved by programmers
and implementers alike. It turned out to have all the properties of a
helpful formalism, viz. compact, unambiguous and amenable to mechanical
manipulation: before the end of decade the construction of parsers
had been mechanized, an achievement that 10 years earlier would have
baffled the imagination. In the case of ALGOL 60, the use of BNF has
had one regrettable effect. Its power should have been used exclusively
to shorten the language definition, but it made the introduction of
new syntactical categories so easy that the final syntax became more
elaborate and more complicated than desirable.
    --Edgar Dijkstra, EWD1284,
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD12xx/EWD1284.html
%
  Mid 1959 I attended a preliminary meeting at which the notion of
"scope" was still very tentative. Computing Science was really still in
its infancy, for there was a constant confusion between the timeless
concept of the program text and the temporal concept of the computation,
a confusion that provoked someone to ask "Do I understand that we
are considering scopes extending from here till then?" I remember,
when I received the final document, the awe with which I observed
how in the block structure the textual concept of scope had been
related to the nested life times of incarnations. It was a beautiful
synthesis, relating computation structure to program structure; as
such it represented a quantum leap in our coming to grips with the
programming task. I was deeply impressed by the block structure, but
have never seen able to find out who in particular has been responsible
for its invention.
    --Edgar Dijkstra, EWD1284,
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD12xx/EWD1284.html
%
  Industry suffers from the managerial dogma that for the sake of
stability and continuity, the company should be independent of the
competence of individual employees. Hence industry rejects any
methodological proposal that can be viewed as making intellectual
demands on its work force....The moral of this sad part of the story is
that as long as computing science is not allowed to save the computer
industry, we had better see to it that the computer industry does not
kill computing science.
    --Edgar Dijkstra, EWD1284,
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD12xx/EWD1284.html
%
I mean, if ten years from now, when you are doing something quick and
dirty, you suddenly visualize that I am looking over your shoulders and
say to yourself, "Dijkstra would not have liked this," well, that would
be enough immortality for me.
    --Edgar Dijkstra
%
If debugging is the process of removing software bugs, then programming
must be the process of putting them in.
    --Edgar Dijkstra
%
It is practically impossible to teach good programming style to students
that have had prior exposure to BASIC. As potential programmers, they
are mentally mutilated beyond hope of regeneration.
    --E. W. Dijkstra
%
Program testing can be used to show the presence of bugs, but never to show
their absence!
    --Edsger Dijkstra, EWD268 (August 1969)
%
The first moral of the story is that program testing can be used very
effectively to show the presence of bugs but never to show their
absence.
    --Edsger Dijkstra, EWD303 (somewhere near the beginning of 1971)
%
The functions I grew up with, such as the sine, the cosine, the square
root, and the logarithm were almost exclusively real functions of a
real argument. Sometimes, but not very explicitly, the argument could
be allowed to be a little bit more complicated, such as the maximum of
two values, a real function defined on a pair of real values, or on two
values: whether the maximum was a function of one argument (which had
to be a pair) or was a function of two arguments (each of which was a
real number) was a question that was avoided....The nett effect was that
I was extremely ill-equipped to appreciate functional programming when
I encountered it: I was, for instance, totally baffled by the shocking
suggestion that the value of a function could be another function.
    --Edsger Dijkstra, EWD1213
%
The question of whether computers can think is like the question of
whether submarines can swim.
    --Edsger W. Dijkstra
%
The use of COBOL cripples the mind; its teaching should therefore be
regarded as a criminal offense.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
The tools we use have a profound (and devious!) influence on our thinking
habits, and, therefore, on our thinking abilities.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
[I]t is impossible to sharpen a pencil with a blunt axe. It is equally
vain to try to do it with ten blunt axes instead.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
Besides a mathematical inclination, an exceptionally good mastery of one's
native tongue is the most vital asset of a competent programmer.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
Many companies...will collapse under the sheer weight of the unmastered
complexity of their data processing systems.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
By claiming that they can contribute to software engineering, the soft
scientists make themselves even more ridiculous. (Not less dangerous,
alas!) In spite of its name, software engineering requires (cruelly)
hard science for its support.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
Projects promoting programming in "natural language" are intrinsically
doomed to fail.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
If the conjecture "You would rather that I had not disturbed you by
sending you this." is correct, you may add it to the list of
uncomfortable truths.
    --Edsger Dijkstra, EWD498 "How do we tell truths that might hurt?"
      http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
%
Simplicity is prerequisite for reliability.
    --Edsger Dijkstra
%
How do we convince people that in programming simplicity and clarity
—in short: what mathematicians call "elegance"— are not a dispensable
luxury, but a crucial matter that decides between success and failure?
    --Edsger Dijkstra, EWD648 "Why is software so expensive?"
      https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD648.html
%
The lurking suspicion that something could be simplified is the
world's richest source of rewarding challenges.
    --Edsger Dijkstra
%
Simplicity is a great virtue but it requires hard work to achieve it
and education to appreciate it. And to make matters worse: complexity
sells better.
    --Edsger Dijkstra
%
We may continue to think that programming is not essentially difficult,
that it can be done by accurate morons, provided you have enough of
them, but then we continue to fool ourselves and no one can do so for
a long time unpunished.
    --Edsger Dijkstra, EWD303
%
If FORTRAN has been called an infantile disorder, PL/1 must be
classified as a fatal disease.
    --Edsger Dijkstra, EWD316 (1971) Preface
%
[T]he true subject matter of the programmer's activity is not the
program he composes, but the class of possible computations that may
be evoked by it, the "production" of which he delegates to the machine.
    --Edsger Dijkstra, EWD316 (1971) Ch. 2
%
I feel somewhat guilty when I have suggested that the distinction or
introduction of "different levels of abstraction" allow you to think about
only one level at a time, ignoring completely the other levels. This is not
true. You are trying to organize your thoughts; that is, you are seeking to
arrange matters in such a way that you can concentrate on some portion, say
with 90% of your conscious thinking, while the rest is temporarily moved
away somewhat towards the background of your mind. But that is something
quite different from "ignoring completely": you allow yourself temporarily
to ignore details, but some overall appreciation of what is supposed to be
or to come there continues to play a vital role. You remain alert for
little red lamps that suddenly start flickering in the corners of your eye.
    --Edsger Dijkstra, personal communication to Donald E. Knuth, 1973-01-03
      Quoted in "Structured Programming with go to Statements"
      https://dl.acm.org/doi/pdf/10.1145/356635.356640
%
Therefore, I have not focused my attention on the question "How do we prove
the correctness of a given program?" but on the questions "for what program
structures can we give correctness proofs without undue labour, even if the
programs get large?"
    --Edsger Dijkstra, EWD268 (August 1969)
%
This what I call "constructive approach to the problem of program
correctness" can be taken a step further. It is not restricted to general
considerations as to what program structures are attractive from the point
of view of provability; in a number of specific, very difficult programming
tasks I have finally succeeded in constructing a program by analyzing how a
proof could be given that a class of computations would satisfy certain
requirements: from the requirements of the proof the program followed.
    --Edsger Dijkstra, EWD268 (August 1969)
%
Please don't fall into the trap of believing that I am terribly dogmatical
about [the go to statement]. I have the uncomfortable feeling that others
are making a religion out of it, as if the conceptual problems of
programming could be solved by a single trick, by a simple form of coding
discipline!
    --Edsger Dijkstra, personal communication to Donald E. Knuth, 1973-01-03
      Quoted in "Structured Programming with go to Statements"
      https://dl.acm.org/doi/pdf/10.1145/356635.356640
%
Indeed, Dijkstra's original article which gave Structured Programming its
name never mentions go to statements at all; he directed attention to the
critical question, "For what program structures can we give correctness
proofs without undue labor, even if the programs get large?" By correctness
proofs he explained that he does not mean formal derivations from axioms,
he means any sort of proof (formal or informal) that is "sufficiently
convincing"; and a proof really means an understanding. By program
structure he means data structure as well as control structure.
    -— Donald Knuth, "Structured Programming with go to Statements"
       https://dl.acm.org/doi/pdf/10.1145/356635.356640
